!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.10 (r5717) - 30 Jul 2015 16:03
!
!  Differentiation of forecast in reverse (adjoint) mode:
!   gradient     of useful results: y
!   with respect to varying inputs: x y
!   RW status of diff variables: x:out y:in-zero
SUBROUTINE LZ95_FORECAST_ADJ(x, xb, yb, n, f, dt)
  ! This subroutine computes the adjoint of the RK4 integration of the Lorenz
  ! governing equations
  !
  ! dX[k] / dt = X[k] * (X[k + 1] - X[k - 2]) - X[k] + F
  !
  ! using Tapenade. The comments above the subroutine were generated by
  ! Tapenade. The auto-generated code was modified to suit the needs of the
  ! user.
  !
  ! Inputs:
  !     x - Vector of X-variables
  !     yb - Direction vector
  !     n - Length of x
  !     F - Constant forcing term
  !
  ! Output:
  !     xb - The adjoint model evaluated at x in the direction of yb.
  !
  ! References:
  !     [1] Lorenz, E. N. and Emanuel K. A. (1998). Optimal Sites for
  !         Supplementary Weather Observations: Simulation with a Small Model.
  !         Journal of the Atmospheric Sciences.
  !
  !     [2] Hascoët, Laurent and Pascual, Valérie. (2013). The Tapenade
  !         Automatic Differentiation Tool: Principles, Model, and
  !         Specification.
  !
  ! Author:             Tapenade 3.10
  ! Edited by:          Jeremy Shaw
  ! Institution:        Portland State University
  ! Date Created:       18 November 2015
  ! Last Modified Date: 20 November 2015
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  DOUBLE PRECISION, DIMENSION(n), INTENT(IN) :: x
  DOUBLE PRECISION, DIMENSION(n), intent(out) :: xb
  DOUBLE PRECISION, DIMENSION(n), intent(in) :: yb
  DOUBLE PRECISION, INTENT(IN) :: f
  DOUBLE PRECISION, INTENT(IN) :: dt
  DOUBLE PRECISION, DIMENSION(n) :: k1
  DOUBLE PRECISION, DIMENSION(n) :: k1b
  DOUBLE PRECISION, DIMENSION(n) :: k2
  DOUBLE PRECISION, DIMENSION(n) :: k2b
  DOUBLE PRECISION, DIMENSION(n) :: k3
  DOUBLE PRECISION, DIMENSION(n) :: k3b
  DOUBLE PRECISION, DIMENSION(n) :: k4b
  DOUBLE PRECISION, DIMENSION(n) :: arg1
  DOUBLE PRECISION, DIMENSION(n) :: arg1b
  DOUBLE PRECISION :: tempb(n)
  CALL LZ95_MODEL(x, k1, n, f)
  arg1(:) = x + dt/2.d0*k1
  CALL LZ95_MODEL(arg1(:), k2, n, f)
  arg1(:) = x + dt/2.d0*k2
  CALL LZ95_MODEL(arg1(:), k3, n, f)
  arg1(:) = x + dt*k3
  xb = 0.D0
  k1b = 0.D0
  k2b = 0.D0
  k3b = 0.D0
  k4b = 0.D0
  tempb = dt*yb/6.d0
  k4b = tempb
  arg1b = 0.D0
  CALL LZ95_MODEL_ADJ(arg1(:), arg1b(:), k4b, n, f)
  xb = arg1b(:) + yb
  k3b = dt*arg1b(:) + 2.d0*tempb
  arg1(:) = x + dt/2.d0*k2
  arg1b = 0.D0
  CALL LZ95_MODEL_ADJ(arg1(:), arg1b(:), k3b, n, f)
  k2b = dt*arg1b(:)/2.d0 + 2.d0*tempb
  xb = xb + arg1b
  arg1(:) = x + dt/2.d0*k1
  arg1b = 0.D0
  CALL LZ95_MODEL_ADJ(arg1(:), arg1b(:), k2b, n, f)
  k1b = dt*arg1b(:)/2.d0 + tempb
  xb = xb + arg1b
  CALL LZ95_MODEL_ADJ(x, xb, k1b, n, f)
END SUBROUTINE LZ95_FORECAST_ADJ
